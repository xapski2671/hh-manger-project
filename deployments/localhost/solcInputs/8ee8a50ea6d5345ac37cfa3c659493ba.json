{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * @notice This is a deprecated interface. Please use AutomationCompatibleInterface directly.\n */\npragma solidity ^0.8.0;\nimport {AutomationCompatibleInterface as KeeperCompatibleInterface} from \"./AutomationCompatibleInterface.sol\";\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/Campaign.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\";\r\n\r\n// errors\r\nerror Campaign__NotInState();\r\nerror Campaign__NotCreator(address _address);\r\nerror Campaign__DonatorIsCreator(address _address);\r\nerror Campaign__PayoutFailed();\r\nerror Campaign__NoDonationsHere(address _donatorAddress);\r\nerror Campaign__RefundFailed();\r\nerror Campaign__UpkeepNotNeeded();\r\nerror Campaign__NotWithrawable(address _campaignAddress);\r\nerror Campaign__AlreadyExpired(address _campaignAddress);\r\nerror Campaign__NotRefundable(address _campaignAddress);\r\nerror Campaign__CampaignBankrupt(address _campaignAddress);\r\n\r\n\r\ncontract Campaign is KeeperCompatibleInterface {\r\n  using SafeMath for uint256;\r\n\r\n  // enums\r\n  enum State {\r\n    Fundraising,\r\n    Expired\r\n  }\r\n\r\n\r\n  // state variables\r\n  address payable public creator;\r\n  string public title;\r\n  string public description;\r\n  string public category;\r\n  string[] public tags;\r\n  uint256 public goalAmount;\r\n  uint256 public duration;\r\n  string public campaignURI;\r\n  uint256 public currentBalance;\r\n  uint256 private s_lastTimeStamp;\r\n  uint256 private maxTimeStamp;\r\n  State public state = State.Fundraising; // default state\r\n  mapping (address => uint256) public donations;\r\n  bool public nowPayable;\r\n  bool public nowRefundable;\r\n\r\n\r\n  struct CampaignObject {\r\n    address creator;\r\n    string title;\r\n    string description;\r\n    string category;\r\n    string[] tags;\r\n    uint256 goalAmount;\r\n    uint256 duration;\r\n    uint256 currentBalance;\r\n    State currentState;\r\n  }\r\n\r\n\r\n  // events\r\n  event FundingRecieved (\r\n    address indexed contributor,\r\n    uint256 amount,\r\n    uint256 currentBalance\r\n  );\r\n  event CreatorPaid(address creator, address campaignAddress);\r\n  event CampaignSuccessful(address campaignAddress);\r\n  event CampaignExpired(address campaignAddress);\r\n\r\n\r\n  // modifiers\r\n  modifier isCreator() {\r\n    if(msg.sender != creator){revert Campaign__NotCreator(msg.sender);}\r\n    _;\r\n  }\r\n\r\n  constructor (\r\n    address _creator,\r\n    string memory _title,\r\n    string memory _description,\r\n    string memory _category,\r\n    string[] memory _tags,\r\n    uint256 _goalAmount,\r\n    uint256 _duration,\r\n    string memory _campaignURI\r\n  ) {\r\n    creator = payable(_creator);\r\n    title = _title;\r\n    description = _description;\r\n    category = _category;\r\n    tags = _tags;\r\n    goalAmount = _goalAmount;\r\n    s_lastTimeStamp = block.timestamp;\r\n    maxTimeStamp = s_lastTimeStamp + 2592000; // 30days\r\n    if(_duration > (maxTimeStamp.sub(s_lastTimeStamp))){\r\n      duration = maxTimeStamp.sub(s_lastTimeStamp);\r\n    }else{\r\n      duration = _duration;\r\n    }\r\n    campaignURI = _campaignURI;\r\n    currentBalance = 0;\r\n    nowPayable = false;\r\n    nowRefundable = true;\r\n  }\r\n\r\n  function donate() external payable {\r\n    if(state != State.Fundraising){revert Campaign__AlreadyExpired(address(this));}\r\n    if (msg.sender == creator){revert Campaign__DonatorIsCreator(msg.sender);}\r\n    donations[msg.sender] = donations[msg.sender].add(msg.value);\r\n    currentBalance = currentBalance.add(msg.value);\r\n    emit FundingRecieved(msg.sender, msg.value, currentBalance);\r\n  }\r\n\r\n  /**\r\n    @dev this is the function chainlink keepers calls\r\n    chekupkeep returns true to trigger the action after the interval has passed\r\n   */\r\n  function checkUpkeep(bytes memory /**checkData */) public view override\r\n  returns (bool upkeepNeeded, bytes memory /**performData */) \r\n  {\r\n    bool isOpen = state == State.Fundraising;\r\n    bool timePassed = ((block.timestamp - s_lastTimeStamp) > duration);\r\n    bool hasBalance = address(this).balance > 0;\r\n    upkeepNeeded = (timePassed && isOpen && hasBalance) ;\r\n    return (upkeepNeeded, \"0x0\");\r\n  }\r\n\r\n  function performUpkeep(bytes calldata /**performData */) external override {\r\n    (bool upkeepNeeded, ) = checkUpkeep(\"\");\r\n    if(!upkeepNeeded){revert Campaign__UpkeepNotNeeded();}\r\n\r\n    // allow creator withdraw funds\r\n    nowPayable = true;\r\n    nowRefundable = false;\r\n    state = State.Expired;\r\n    emit CampaignExpired(address(this));\r\n    if(currentBalance >= goalAmount){\r\n      emit CampaignSuccessful(address(this));\r\n    }\r\n  }\r\n\r\n  function payout() public isCreator {\r\n    if(!nowPayable){revert Campaign__NotWithrawable(address(this));}\r\n    uint256 totalRaised = currentBalance;\r\n    currentBalance = 0;\r\n    (bool success, ) = creator.call{value: totalRaised}(\"\");\r\n    if(success){\r\n      nowRefundable = false;\r\n      emit CreatorPaid(creator, address(this));\r\n    }\r\n    else{revert Campaign__PayoutFailed();}\r\n  }\r\n\r\n  function refund() public {\r\n    if(!nowRefundable){revert Campaign__NotRefundable(address(this));}\r\n    if(donations[msg.sender] <= 0){revert Campaign__NoDonationsHere(msg.sender);}\r\n    uint256 amountToRefund = donations[msg.sender];\r\n    donations[msg.sender] = 0;\r\n    if(currentBalance < amountToRefund){revert Campaign__CampaignBankrupt(address(this));}\r\n    currentBalance = currentBalance.sub(amountToRefund);\r\n    (bool success, ) = payable(msg.sender).call{value: amountToRefund}(\"\");\r\n    if(!success){revert Campaign__RefundFailed();} // TODO: test if it returns value (the money) to mapping\r\n  }\r\n\r\n  function endCampaign() public isCreator {\r\n    if(state == State.Expired){revert Campaign__AlreadyExpired(address(this));}\r\n    state = State.Expired;\r\n    nowRefundable = false;\r\n    if(currentBalance > 0){nowPayable = true;}\r\n    emit CampaignExpired(address(this));\r\n  }\r\n\r\n  // update functions\r\n  function updateTitle(string memory _newTitle) public isCreator {\r\n    title = _newTitle;\r\n  }\r\n\r\n  function updateDescription(string memory _newDescription) public isCreator {\r\n    description = _newDescription;\r\n  }\r\n\r\n  function updateCategory(string memory _newCategory) public isCreator {\r\n    category = _newCategory;\r\n  }\r\n\r\n  function updateGoalAmount(uint256 _newGoalAmount) public isCreator {\r\n    goalAmount = _newGoalAmount;\r\n  }\r\n\r\n  function updateDuration(uint256 _additionalTime) public isCreator {\r\n    if(_additionalTime + duration > (maxTimeStamp.sub(s_lastTimeStamp))){\r\n      duration = maxTimeStamp.sub(s_lastTimeStamp); // 30days\r\n    }\r\n    else{\r\n      duration += _additionalTime;\r\n    }\r\n  }\r\n  \r\n  // getter functions\r\n  function getCreator() public view returns(address) {\r\n    return creator;\r\n  }\r\n\r\n  function getBalance() public view returns(uint256) {\r\n    return currentBalance;\r\n  }\r\n\r\n  function getCampaignState() public view returns(State) {\r\n    return state;\r\n  }\r\n\r\n  function getDonations(address _donator) public view returns(uint256) {\r\n    return donations[_donator];\r\n  }\r\n\r\n  function getCampaignDetails() public view returns(CampaignObject memory) {\r\n    return CampaignObject(\r\n      creator,\r\n      title,\r\n      description,\r\n      category,\r\n      tags,\r\n      goalAmount,\r\n      duration,\r\n      currentBalance,\r\n      state\r\n    );\r\n  }\r\n}"
    },
    "contracts/CrowdFunder.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"./Campaign.sol\";\r\n\r\n// errors\r\nerror CrowdFunder__NotCreator(address _caller, address _campaignAddress);\r\nerror CrowdFunder__CampaignStillActive(address _campaignAddress);\r\nerror CrowdFunder__DonationFailed(address _campaignAddress);\r\nerror CrowdFunder__RefundFailed(address _campaignAddress);\r\n\r\ncontract CrowdFunder {\r\n  using SafeMath for uint256;\r\n\r\n  event UserAdded(\r\n    address indexed _address,\r\n    string _username,\r\n    string _twitter,\r\n    string _email,\r\n    string _bio\r\n  );\r\n\r\n  event CampaignAdded(\r\n    address indexed _campaignAddress,\r\n    address indexed _creator,\r\n    string _title,\r\n    string _description,\r\n    string _category,\r\n    string[] _tags,\r\n    uint256 _goalAmount,\r\n    uint256 _duration,\r\n    string _campaignURI\r\n  );\r\n\r\n  event CampaignFunded(\r\n    address indexed _funder,\r\n    address indexed _campaignAddress\r\n  );\r\n\r\n  event CampaignShrunk(\r\n    address indexed _withdrawer,\r\n    address indexed _campaignAddress\r\n  );\r\n\r\n  event CampaignCanceled(\r\n    address indexed _campaignAddress\r\n  );\r\n\r\n\r\n  mapping (address => Campaign) campaigns;\r\n  mapping (address => address[]) campaignsBacked;\r\n\r\n\r\n  modifier isCreator(address _campaignAddress) {\r\n    if(campaigns[_campaignAddress].getCreator() != msg.sender){\r\n      revert CrowdFunder__NotCreator(msg.sender, _campaignAddress);\r\n    }\r\n    _;\r\n  }\r\n\r\n  function addUser(address _address, string memory _username, string memory _twitter, string memory _email, string memory _bio) public {\r\n    emit UserAdded(_address, _username, _twitter, _email, _bio);\r\n  }\r\n\r\n  function addCampaign (\r\n    string memory _title, \r\n    string memory _description,\r\n    string memory _category,\r\n    string[] memory _tags, \r\n    uint256 _goalAmount,\r\n    uint256 _duration,\r\n    string memory _campaignURI\r\n    ) external {\r\n    Campaign newCampaign = new Campaign(payable(msg.sender), _title, _description, _category, _tags, _goalAmount, _duration, _campaignURI);\r\n    campaigns[address(newCampaign)] = newCampaign;\r\n    emit CampaignAdded(address(newCampaign), msg.sender, _title, _description, _category, _tags, _goalAmount, _duration, _campaignURI);\r\n  }\r\n\r\n  function donateToCampaign (address _campaignAddress) public payable {\r\n    (bool success, bytes memory data) = _campaignAddress.delegatecall(abi.encodeWithSignature(\"donate()\"));\r\n    if(success){\r\n      emit CampaignFunded(msg.sender, _campaignAddress);\r\n    }else{\r\n      if(data.length>0){revert(string(abi.encodePacked(data)));}\r\n      else{revert CrowdFunder__DonationFailed(_campaignAddress);}\r\n    }\r\n  }\r\n\r\n  function refundFromCampaign(address _campaignAddress) public {\r\n    (bool success,) = _campaignAddress.delegatecall(abi.encodeWithSignature(\"refund()\"));\r\n    if(success){\r\n      emit CampaignShrunk(msg.sender, _campaignAddress);\r\n    }else{\r\n      // if(data.length>0){revert(string(abi.encodePacked(data)));}\r\n      // if(data.length>0){revert(\"refund failed from source\");}\r\n      revert CrowdFunder__RefundFailed(_campaignAddress);\r\n    }\r\n  }\r\n\r\n  function cancelCampaign (address _campaignAddress) public isCreator(_campaignAddress) {\r\n    if(uint(campaigns[_campaignAddress].getCampaignState()) == 1){revert CrowdFunder__CampaignStillActive(_campaignAddress);}\r\n    delete(campaigns[_campaignAddress]);\r\n    emit CampaignCanceled(_campaignAddress);\r\n  }\r\n\r\n  function getCampaign(address _campaignAddress) external view returns (Campaign.CampaignObject memory) {\r\n    return campaigns[_campaignAddress].getCampaignDetails();\r\n  }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}